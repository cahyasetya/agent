"""
API client for interacting with language models.
Provides functionality to call OpenRouter API and handle responses.
"""

import os
import requests
from typing import List, Dict, Optional, Any

from .console import console

# --- Configuration ---
OPEN_ROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_API_BASE = "https://openrouter.ai/api/v1"
LLM_MODEL = "google/gemini-2.5-flash-preview"

# --- Context Management Configuration ---
MAX_HISTORY_ITEMS = 10  # Keep this many recent messages plus system prompt


def prune_messages(messages_list: List[dict], max_items: int) -> List[dict]:
    """
    Prunes the messages list to keep the system prompt and a window of recent messages.
    
    Args:
        messages_list (list): The list of messages to prune
        max_items (int): Maximum number of messages to keep (plus system prompt)
        
    Returns:
        list: The pruned list of messages
    """
    if len(messages_list) <= max_items + 1:
        return messages_list

    system_prompt = [messages_list[0]]
    recent_messages = messages_list[-max_items:]

    pruned_list = system_prompt + recent_messages
    msg = "[info]--- Context Pruning: Reduced message history from "
    msg += f"{len(messages_list)} to {len(pruned_list)} items. ---[/info]"
    console.print(msg)
    return pruned_list


def call_openrouter_api(
    messages: List[Dict[str, str]], 
    model: str = LLM_MODEL, 
    tools: Optional[List[Dict[str, Any]]] = None, 
    tool_choice: Optional[str] = None
) -> Dict[str, Any]:
    """
    Make a direct API call to OpenRouter.
    
    Args:
        messages (list): The messages to send to the API
        model (str): The model to use for the API call
        tools (list, optional): Tool definitions to include in the API call
        tool_choice (str, optional): Tool choice parameter for the API call
        
    Returns:
        dict: The API response as a dictionary
    """
    endpoint = f"{OPENROUTER_API_BASE}/chat/completions"

    headers = {
        "Authorization": f"Bearer {OPEN_ROUTER_API_KEY}",
        "Content-Type": "application/json",
    }

    payload = {"model": model, "messages": messages}

    if tools:
        payload["tools"] = tools

    if tool_choice:
        payload["tool_choice"] = tool_choice

    try:
        response = requests.post(
            endpoint, headers=headers, json=payload, timeout=90
        )

        response.raise_for_status()
        return response.json()

    except requests.exceptions.RequestException as e:
        console.print(f"[error]API Request Error: {e}[/error]")
        if hasattr(e, "response") and e.response is not None:
            try:
                error_body = e.response.json()
                console.print(f"[error]Error details: {error_body}[/error]")
            except Exception as json_err:
                err_msg = f"[error]Error parsing response: {json_err}[/error]"
                console.print(err_msg)
                status_msg = "[error]Error status code: "
                status_msg += f"{e.response.status_code}[/error]"
                console.print(status_msg)
                err_text = f"[error]Error text: {e.response.text}[/error]"
                console.print(err_text)
        raise e


def get_system_prompt(focus_path: Optional[str] = None) -> str:
    """
    Create the system prompt for the agent.
    
    Args:
        focus_path (str, optional): Path to focus on for this session
        
    Returns:
        str: The system prompt
    """
    system_content = (
        "You are a helpful assistant for refactoring and managing files. "
        "You can use tools to list directory contents, read files, write content "
        "to files, create empty files, create directories, search for files, or "
        "get a diff of proposed changes to a file if needed. "
        "You also have tools to delete files and directories, and move files "
        "(with wildcard support). "
        "Paths are relative to the script's current working directory. "
        "Maintain context from previous turns to understand follow-up questions. "
        "\n\nRefactoring/Editing Workflow (VERY IMPORTANT):\n"
        "1. When asked to modify or refactor an existing file, first use "
        "`read_file_content` to get its current, full content.\n"
        "2. Based on the user's request, formulate the complete, new, full content "
        "of the file as it should be after the changes. This means the entire file, "
        "not just the changed parts.\n"
        "3. Then, use the `get_diff_for_proposed_changes` tool. Provide it with the "
        "original `file_path` and your complete, new, full `proposed_new_content`.\n"
        "4. Present the diff generated by the tool to the user for review. The diff "
        "will be colorized (green for additions, red for deletions) for easier "
        "reading in the terminal.\n"
        "5. After presenting the diff, wait for the user's feedback. If the user "
        "rejects the changes or asks for different modifications, engage in a "
        "dialogue to understand their requirements and, if necessary, repeat "
        "steps 2-4.\n"
        "6. If the user confirms the changes (e.g., by saying 'yes', 'proceed', "
        "'apply changes'), then and only then, use the `write_to_file` tool.\n"
        "Do not write only partial changes or just function signatures unless that "
        "is the entirety of the intended new file content. If creating a new file, "
        "the diff step can show the entire content as new.\n"
        "\n\nFile Movement and Organization:\n"
        "You can use the `move_files` tool to move files or directories, including "
        "with wildcard patterns like *.py or data/*.csv. "
        "Be careful when using wildcards and always confirm with the user before "
        "executing operations that might affect multiple files.\n"
        "\n\nRich Output Support:\n"
        "You can use the `rich_output` tool to format your responses with syntax "
        "highlighting, markdown rendering, and panels with borders.\n"
        "\n\nSyntax Highlighting:\n"
        "You can use the `syntax_highlight` tool to show the content of code files "
        "with proper syntax highlighting. Code width should be 80"
        "\n\nFocus Path Behavior:\n"
        "Most file operation tools support a `use_focus_path` parameter which defaults to true. "
        "When true, paths are relative to the focus directory if one is set. "
        "When false, paths are always relative to the current working directory. "
        "This allows flexibility in working with files in different directories."
        "\n\nConversation Management:\n"
        "You have access to tools for saving and loading conversations. The user can use "
        "these tools by typing commands directly (save, load, clear) or by asking you "
        "to do it for them. The dump_messages tool saves the current conversation to a file, "
        "and load_messages loads a previously saved conversation."
    )

    if focus_path:
        abs_focus_path = os.path.abspath(focus_path)  # Convert to absolute path
        context_msg = (
            f"\n\nIMPORTANT CONTEXT: The user has specified a focus directory for "
            f"this session: '{abs_focus_path}'. "
            "Please prioritize operations, suggestions, and file paths within or "
            "relative to this directory unless explicitly told otherwise. When "
            "providing file paths in your responses or tool arguments, use paths "
            "relative to the focus directory by default. "
            "If a user refers to 'this directory' or 'the project folder', "
            "assume they mean this focus directory. "
            "By default, all paths provided to tools like read_file_content will "
            "be considered relative to this focus directory. "
            "If the user wants to operate on files outside the focus directory but within "
            "the allowed scope, they can pass use_focus_path=False to the appropriate tool.")
        system_content += context_msg

    return system_content
